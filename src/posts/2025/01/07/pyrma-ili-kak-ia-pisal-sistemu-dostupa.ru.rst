.. title: pyRMA или как я писал систему доступа
.. slug: pyrma-ili-kak-ia-pisal-sistemu-dostupa
.. date: 2025-01-31 00:00:00 UTC+03:00
.. tags: ssh, security, pyrma, remote access
.. category: linux
.. link: 
.. description: pyRMA - Remote access control system for server and network equipment via SSH and TELNET protocols.
.. type: text
.. author: Sergey <DerNitro> Utkin
.. previewimage: /images/posts/pyrma-ili-kak-ia-pisal-sistemu-dostupa/patrick-robert-doyle--XiKxvvFGgU-unsplash.jpg

.. _Patrick Robert Doyle: https://unsplash.com/@teapowered?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash
.. _Unsplash: https://unsplash.com/photos/a-red-and-white-sign-sitting-on-the-side-of-a-road--XiKxvvFGgU?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash

.. |PostImage| image:: /images/posts/pyrma-ili-kak-ia-pisal-sistemu-dostupa/patrick-robert-doyle--XiKxvvFGgU-unsplash.jpg
    :width: 40%
    :target: `Patrick Robert Doyle`_

.. |PostImageTitle| replace:: Photo by `Patrick Robert Doyle`_ on Unsplash_

.. _Python: https://www.python.org/
.. |Python| replace:: **Python**

.. _pyRMA: https://github.com/DerNitro/pyRMA
.. |pyRMA| replace:: **pyRMA**

.. _npyscreen: https://github.com/npcole/npyscreen
.. |npyscreen| replace:: npyscreen

.. _alembic: https://alembic.sqlalchemy.org/en/latest/tutorial.html
.. |alembic| replace:: alembic

.. _Linux PAM: https://www.man7.org/linux/man-pages/man8/pam.8.html
.. |Linux PAM| replace:: Linux PAM

.. _python-pam: https://pypi.org/project/python-pam/
.. |python-pam| replace:: python-pam


|PostImage|

|PostImageTitle|

------

2014 год. Я молодой и перспективный инженер технической поддержки, получаю задачу помочь более старшему коллеге в создании 
системы контроля доступа к аппаратно-программным комплексам наших клиентов.

Концепт был простой, организовать `"SSH jump"` узел, в котором через `CLI` можно выбрать необходимый клиентский узел.
Система фиксировала кто, куда и когда подключался, и на основе этих данных можно будет восстановить картину, если вдруг
что то пошло не так на клиентских системах.

Решение было готово, на `freebsd` с использованием нативного `jail <https://docs.freebsd.org/en/books/handbook/jails/#classic-jail>`_
и `CLI` на основе `bash` скрипта. Но при подаче пользовательской нагрузки - возникли проблемы, и система стала не работоспособной,
подробностей не помню, но были связаны на блокировках при работе с базой данных, которая была на `sqlite <https://www.sqlite.org/>`_.

Пока старший инженер вносил правки в `bash` скрипты, я накидал "на коленке" свое прочтение задачи на `python`, которое 
заработало и я получил карт-бланш, на доработку. Разработка решения на `freebsd` была прекращена.

Шли годы, решение работало, но код написанный "на коленке", создало огромный тех-долг, и в какой то момент, развитие системы
было более не возможно. Настал момент переписать и `поделится кодом <https://github.com/DerNitro/pyRMA>`_ со всем миром.

Ну давай те посмотрим под "капот", что из этого получилось.

.. note::

    Я не настоящий программист, по этому я не претендую что:

    * Архитектура системы идеальна
    * Код написан профессионально
    * Что система безопасна
    * и так далее и тому подобное

    Но создание данной системы помогло мне развить мои навыки, которые помогли мне далее в моей работе.

.. TEASER_END

Требования
==========

За несколько лет работы первой версии системы доступа, определился список требований:

1. Подключение к клиентским системам по протоколам `SSH` и `Telnet`, в том числе и с поддержкой `Jump host <https://www.ssh.com/academy/ssh/command#ssh-command-line-options>`_
#. Разграничение доступа к клиентским системам для пользователя или группы пользователей
#. Возможность запросить и согласовать доступ до клиентских систем пользователей
#. Возможность передать/скачать файл с клиентских систем
#. Возможность прокинуть TCP/UDP порты на клиентские системы
#. Возможность подключения к `IPMI <https://ru.wikipedia.org/wiki/Intelligent_Platform_Management_Interface>`_ клиентского оборудования
#. Возможность просмотреть пользовательскую сессию
#. Разделение ролей [1]_ пользователя, оператора и администратора системы доступа

Описание системы
================

Как уже ранее было сказано код системы написан на |Python|_ и состоит из следующих элементов:

* Интерфейс подключения
* Интерфейс передачи данных
* WEB интерфейс
* Модуль управления правилами `iptables`
* База данный PostgreSQL

По своей сути система является "единой точкой входа", позволяющая пользователю выбрать интересующий хост и подключится к нему

.. image:: /images/posts/pyrma-ili-kak-ia-pisal-sistemu-dostupa/pyrma.png

Пользовательский сценарий выглядит следующим образом:

1. Пользователь подключается к системе доступа по протоколу SSH
#. Система доступа определяет, по атрибутам пользователя, может ли пользователь иметь доступ, если выполняется 
   первичное подключение, то формируется запрос на доступ и отправляется на согласование администратору системы
#. При успешном подключении к системе, будет запущен консольный интерфейс в котором будет представлен список всех 
   зарегистрированных узлов
#. Пользователь выбирает необходимый узел и может выбрать несколько типов действий:
  
    * Подключится к узлу по протоколу `SSH` или `Telnet`
    * Подключится к узлу в режиме передачи файлов
    * Подключить к узлу только `Сервисы` [2]_

#. Если пользователю не разрешено подключение, то будет создан запрос на доступ и отправлен оператору на согласование.
#. По окончанию подключения пользователя к узлу, информация о сессии, запись TTY консоли, дампы сетевого трафика, будут 
   хранится в системе доступа, и доступны для просмотра администратору и оператору системы.

Система доступа
===============

Подключение к системе доступа
-----------------------------

Подключение к системе осуществляется по протоколу SSH, и нужно было решить сразу несколько вопросов

1. Аутентификация пользователей, кто должен попадать сразу в систему доступа, а кто в командный интерпретатор.
#. Запуск консольного интерфейса системы доступа
#. Начать запись TTY сессии

Первая попытка организовать аутентификацию пользователей была основана на проекте `pam-pgsql <https://github.com/pam-pgsql/pam-pgsql>`_
которая позволяет хранить пользовательские данные в СУБД PostgreSQL, но пришлось отказаться от данного решения, так как 
требовало больший вложений, таких как:

* Обеспечение информационной безопасности хранения пользовательских данных в СУБД
* Разработка механизма синхронизации с корпоративными системами `Службы каталогов`
* `pam-pgsql` полумертвый проект, есть не решенные тикеты с проблемами от 2016 года, большой риск потом переписывать
  часть аутентификации в системе.

Решение было оставить авторизацию на |Linux PAM|_, при подключении 
по SSH PAM включается параметром ``UsePAM yes`` а для web интерфейса был использован модуль |python-pam|_,
это позволило оставить на "плечах" администратора системы источник данных для аутентификации.

Для дальнейшей работы с пользовательскими данными мы информацию о пользователе и его группах получаем через возможности 
стандартной библиотеки |Python|_ `pwd — The password database <https://docs.python.org/3.8/library/pwd.html>`_ и 
`grp — The group database <https://docs.python.org/3.8/library/grp.html>`_, на основе групп пользователя, в системе,
определяются права доступа и отображения информации.

После прохождения аутентификации и авторизации, нам нужно запустить интерфейс системы доступа, для этого мы заменим командный
интерпретатор на запуск нашей консоли.

`Серверная часть SSH <https://man7.org/linux/man-pages/man5/sshd_config.5.html>`_ позволяет для пользователей 
переопределять команду запуска при подключении.

.. note::

    ForceCommand
        Forces the execution of the command specified by
        ForceCommand, ignoring any command supplied by the client
        and ~/.ssh/rc if present.  The command is invoked by
        using the user's login shell with the -c option.  This
        applies to shell, command, or subsystem execution.  It is
        most useful inside a Match block.  The command originally
        supplied by the client is available in the
        SSH_ORIGINAL_COMMAND environment variable.  Specifying a
        command of internal-sftp will force the use of an in-
        process SFTP server that requires no support files when
        used with ChrootDirectory.  The default is none.

Переопределим данный параметр для всех пользователей кроме администраторов системы

.. code-block::

    Match User *,!acs,!root
        ForceCommand /srv/acs/bin/pyrma.sh
        AllowTcpForwarding no
        X11Forwarding no

и внесем переопределенный интерпретатор в список доверенных ``/etc/shells``. Теперь все пользователи, при подключении к SSH
попадут в наш скрипт который который запустит консольный интерфейс системы доступа и запись TTY сессии.

В качестве утилиты для захвата пользовательского терминала выбор пал на `asciinema <https://docs.asciinema.org/>`_.
На момент разработки имел ряд преимуществ:

* Активная разработка проекта
* Есть пакет APT в репозитории для ОС Linux Ubuntu 20.04
* Существует встраиваемый в HTML плеер, который был успешно встроен в WEB интерфейс
* Запись канала stdin, позволил проводить анализ вводимых команд
* Передача ``shell`` команды для записи

с помощью последнего пункта мы как раз и запускаем интерфейс системы доступа.

Интерфейс подключения
---------------------

Сразу при подключении к системе доступа, `запускается консольный интерфейс <https://github.com/DerNitro/pyRMA/blob/master/bin/pyrma.py>`_.

--------

.. image:: /images/posts/pyrma-ili-kak-ia-pisal-sistemu-dostupa/cli.gif

--------

Для создания интерфейса использовалась библиотека |npyscreen|_. На момент написания |pyRMA|_
проект был более активный, чем сейчас.

Библиотека имеет большие возможности, что бы создать много оконное приложение, огромное количество виджетов, и возможность
создать свой, позволяет создать интерфейс на любой вкус.

Функционал который был реализован:

* Список узлов, с возможностью поиска и фильтрации элементов
* Отображением информацией о узле
* Запрос доступа на подключение к узлу

Интерфейс передачи файлов
-------------------------

При нажатии в консольном приложении кнопки *Передача файлов*, запускается интерфейс передачи файлов.

--------

.. image:: /images/posts/pyrma-ili-kak-ia-pisal-sistemu-dostupa/ft.gif

--------

Отображение интерфейса написано так же на |npyscreen|_. Для получения списка и передачи файлов использовал `pysftp <https://pypi.org/project/pysftp/>`_.

.. note::

    Для начала передачи данных, пользователю по SFTP необходимо на систему доступа закачать файл, после чего он будет
    доступен в интерфейсе

Одной из задач данного интерфейса было сохранение информации о переданных файлах, как на узел назначения, так и в обратную сторону.
Реализовано оно следующим образом

1. Переданный файл или директория архивируется в ``tar.gz``
#. С полученного архива снимается ``md5`` хэш сумма
#. Выполняется проверка наличия данной хэш суммы в базе данных
#. При наличии в базе хэш суммы, создается ``hardlink`` на найденный архив
#. При отсутствии архив переноситься в директорию хранения, и соответствующая запись заноситься в базу данных

Благодаря ``hardlink`` и ``tar.gz`` получаем экономию места и отсутствие дублирующих данных

Все переданные файлы доступны в интерфейсе `оператора` и могут быть скачаны для анализа.

Подключения
-----------

`Интерфейс подключения` возвращает объект подключения(SSH, FTP, TELNET etc.) у которого запускается функции 
``run()``, ``connection()`` и ``close()``.

* ``run()`` - Запускает необходимые, для подключения, сервисы, заносит информацию о подключении в базу данных, формирует
  правила ``iptables``.
* ``connection()`` - Запускает непосредственно подключение, это может быть как дочерний процесс, так и отдельный интерфейс консоли
* ``close()`` - Закрывает все ранее созданные сервисы, подключения, и удаляет правила ``iptables``, обновляет информацию о подключении
  в базе данных.

По окончанию подключения, так же закрывается запись TTY сессии, которая так же доступна для просмотра в web интерфейсе
`оператора`.

SSH/TELNET
^^^^^^^^^^

Реализованы популярные протоколы для подключения. Подключение выполняется через запуск дочернего процесса, так же при необходимости
запускается цепочка ``Jump`` узлов, если это необходимо.

SFTP
^^^^

Запускается отдельный интерфейс передачи файлов, и при необходимости формируется цепочка подключений, если узел не доступен на прямую

IPMI/iLo
^^^^^^^^

На текущий момент просмотр записи не доступен, но данное тип подключения регулируется отдельным набором прав пользователя.
Но для текущего подключения будет запущена запись пользовательского сетевого трафика, данный дамп будет доступен для
скачивания через интерфейс `оператора`.

Сервисы
^^^^^^^

Иногда одного подключения к узлу назначения не достаточно, например нужно подключится к базе данных на узле используя локально
установленное ПО(например `pgadmin <https://www.pgadmin.org/>`_).

Система доступа позволяет создавать и подключать к узлам данные сервисы.

При подключении сервиса, на системе доступа стартует запись пользовательского трафика и потом доступна из интерфейса `оператора`.

База данных
-----------

База данных используется не только для хранения данных, но и для хранения текущего состояния

* Правила проброса сервисов
* Правила записи сетевого трафика

--------

.. image:: /images/posts/pyrma-ili-kak-ia-pisal-sistemu-dostupa/db.png

--------

Для работы и доступа к базе данных используется библиотека ``ORM`` `SQLAlchemy <https://www.sqlalchemy.org/>`_.

.. note::

  ORM (англ. Object-Relational Mapping, рус. объектно-реляционное отображение, или преобразование) — технология
  программирования, которая связывает базы данных с концепциями объектно-ориентированных языков программирования,
  создавая «виртуальную объектную базу данных».

Что понравилось:

* Работа с записями/таблицами как с объектами
* Описание таблиц в коде
* Интеграция с |alembic|_

Не понравился один только момент, высокий порог входа в инструмент.

Для первоначального наполнения базы данных и для управления обновлением используется |alembic|_, не простой инструмент и так же требует
изучения, но это того стоит, инструмент позволяет хранить состояние базы данных и при вызове обновления |alembic|_ автоматически 
переведет базу в актуальное состояние.

Firewall
--------

Одним из модулей |pyRMA|_ является подсистема управлением сетевого трафика, название получило из-за управления правилами 
`iptables <https://linux.die.net/man/8/iptables>`_.

--------

.. image:: /images/posts/pyrma-ili-kak-ia-pisal-sistemu-dostupa/firewall.png

--------

Данный модуль запускается как системный сервис. В базе данных существует отдельная таблица,в которую заносятся актуальные правила,
сервис собирает данные правила и актуализирует правила ``iptables``.

Так же данный сервис управляет записью сетевого трафика и сохранением информации о нем в пользовательской сессии.

Веб-интерфейс
-------------

Администрирование и просмотр сессии пользователя выполняется через web интерфейс. Веб сервис написан на 
`Flask <https://flask.palletsprojects.com/en/stable/>`_, дополнительно интегрирован механизм CSRF токенов через 
`Flask-WTF <https://pypi.org/project/Flask-WTF/>`_.

--------

.. image:: /images/posts/pyrma-ili-kak-ia-pisal-sistemu-dostupa/web_connection.png

--------

Веб-интерфейс доступен для всех пользователей, но просмотр информации, только согласно выданным правам.

Так как наша система не хранит данные авторизации и полностью завязана на |Linux PAM|_, здесь мы так же используем 
данный механизм авторизации. Модуль |python-pam|_ позволяет легко проверить данные аутентификации

.. code-block:: python

  >>> import pam
  >>> p = pam.authenticate()
  >>> p.authenticate('user', 'correctpassword')
  True
  >>> p.authenticate('user', 'badpassword')
  False

Так же через веб интерфейс были реализованы функции 

**мониторинга системы**

Позволяя отслеживать количество активных подключений, наличие новых пользователей и ожидающих запросов на подключение

.. code-block::

  in  > curl -u username:password -X GET http://pyrma:8080/api/monitor
  out > {
  out >     "active_connection": 0,
  out >     "new_user": 0,
  out >     "access_request": 0
  out > }

**Загрузка узлов**

Создание в ручную узлов хорошо, но если их много, то можно воспользоваться загрузкой, для загрузки необходим CSV файл.

.. code-block::

  in  > curl -u username:password -X POST -H "Content-Type: multipart/form-data" -F 'file=@tests/eggs.csv' http://pyrma:8080/api/host/upload
  out > {
  out >     "status": "success",
  out >     "created host": 0,
  out >     "updated host": 1000,
  out >     "skipped host": 0
  out > }


Права пользователей
-------------------

Права пользователей разделены на 2 группы,

**подключение:**

* Подключение к узлу
* Передача файлов
* Подключение сервисов совместно с подключением к узлу
* Подключение только сервисов
* Подключение к интерфейсу управления сервером

**пользовательские:**

* Просмотр информации об узле
* Редактирование информации узлов
* Создание|Редактирование директорий
* Смена родителя для узлов
* Отображение логина
* Отображение пароля
* Просмотр сессии пользователя
* Согласование доступов
* Редактирование учетных данных подключения

Права хранятся в базе данных в виде одного ``integer`` числа.

.. code-block::

  11100 = 28
  ││││└── Подключение к интерфейсу управления сервером
  │││└── Подключение только сервисов
  ││└── Подключение сервисов совместно с подключением к узлу   
  │└── Передача файлов
  └── Подключение к узлу

Данный подход мне показался более управляемым, использую логическое сложение для вложенных директорий мы получим конечный результат
прав пользователя

.. code-block::

  ROOT                                        00000
  └── Level1                                  10000
      └── Level2                              01101
          └── Host1    Права для узла будут = 11101
                                              
Что бы пользователь мог пользоваться системой доступа, в системе должна быть зарегистрирована группа в которую этот
пользователь входит. Для зарегистрированной группы можно устанавливать права и предоставлять доступ ко всем узлам или
группе узлов.

Если у пользователя нет доступа на подключение к узлу, он через систему доступа может сформировать запрос на доступ,
который `оператор` может принять или отклонить.

--------

.. image:: /images/posts/pyrma-ili-kak-ia-pisal-sistemu-dostupa/access_request.png

--------

Установка
---------

Для установки был подготовлен ``Ansible`` playbook который полностью выполняет установку и запуск системы доступа.

Послесловие
===========

Разработка текущего состояния длилась неприлично долго - 6 лет, с 2016 по 2022 год. Совмещение работы по найму, семьи и 
решения бытовых проблем, совсем не оставляют времени на разработку.

По этому я принял решение выложить код на GitHub, возможно кого то заинтересуют данные наработки и начнут контрибьютить в 
проект ну или на худой конец форкнут репозиторий.

.. note::
  
  Почему ``pyRMA(пай-эр-мэ-а)`` - python ``Management`` ``Remote`` ``Access``, буквы специально переставлены,
  что бы сложилось более лаконичное название, отсылающее нас к 
  ``Парма — одно из названий Перми Великой или Биармии — территорий на северо-западе Урала (от финно-угорского корня, обозначающего заросший лесом холм)``. 
  Откуда я и родом.

--------

.. figure:: /images/posts/pyrma-ili-kak-ia-pisal-sistemu-dostupa/finish.webp
  :width: 40%
  :align: center
  
  ``Photo by ChatGPT``

--------

.. [1] Сама система не имеет объектов `пользователь`, `оператор` и `администратор`, разделение осуществляется на основе 
       выданных прав.
.. [2] Сервис в системе доступа это системные программное обеспечение на узле назначения, которое имеет сокет для 
       подключения по протоколам `TCP` или `UDP`.
